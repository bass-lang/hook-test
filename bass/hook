#!/usr/bin/env bass

(def *memos*
  *dir*/memos.json)

(use (.hmac)
     (.strings)
     (.git (linux/alpine/git))
     (git:github/vito/tabs/ref/main/gh))

; (defn main []
;   (let [request (next (read *stdin* :json))
;         event request:headers:X-GitHub-Event
;         signature request:headers:X-Hub-Signature-256
;         [algo key] (strings:split signature "=")
;         body (read request:body :raw)]
;     (if (hmac:verify algo key body)
;       (emit body *stdout* :raw)
;       (error "invalid signature"))))

; CGI
; (defn main []
;   (let [secret (mask *env*:WEBHOOK_SECRET :webhook-secret)
;         event *env*:HTTP_X_GITHUB_EVENT
;         signature *env*:HTTP_X_HUB_SIGNATURE_256
;         [scheme claim] (strings:split signature "=")
;         hmac-scheme (hmac:scheme scheme)
;         body (next (read *stdin* :raw))]
;     (if (hmac-scheme:verify secret claim body)
;       (emit true *stdout*)
;       (error "invalid signature"))))

; not CGI, but stdin is still request body
; (defn main []
;   (let [event *headers*:X-GitHub-Event
;         signature *headers*:X-Hub-Signature-256
;         [algo key] (strings:split signature "=")
;         body (next (read *stdin* :raw))]
;     (if (hmac:verify algo key body)
;       (emit true *stdout*)
;       (error "invalid signature"))))

(def *hook-secret*
  (mask *env*:WEBHOOK_SECRET :hook-secret))

(def *client-secret*
  (mask *env*:CLIENT_SECRET :client-secret))

(defn create-check [repo & kwargs]
  (read
    (-> ($ gh api (str "repos/" repo "/check-runs"))
        (gh:with-auth *client-secret*)
        (gh:with-flags :method "POST")
        (with-stdin [(list->scope kwargs)]))
    :json))

(defn update-check [repo run-id & kwargs]
  (read
    (-> ($ gh api (str "repos/" repo "/check-runs/" run-id))
        (gh:with-auth *client-secret*)
        (gh:with-flags :method "PATCH")
        (with-stdin [(list->scope kwargs)]))
    :json))

(defn main []
  (let [request (next *stdin*)]
    (verify request)
    (emit (handle request:headers:X-Github-Event request:body)
          *stdout*)))

(defn verify [{headers :headers body :body}]
  (let [signature headers:X-Hub-Signature-256
        [scheme claim] (strings:split signature "=")
        hmac-scheme (hmac:scheme scheme)]
    (if (hmac-scheme:verify *hook-secret* claim body)
      :ok
      (error "invalid signature"))))

(defn handle [event body]
  (let [payload (decode-json body)]
    (case event
      "check_suite"
      (case payload:action
        "requested"
        (do
          (go
            (let [src (clone payload:repository payload:check-suite:after)
                  project (load (src/project))
                  checks (project:checks src)]
              (reduce-kv (fn [check thunk] (run-check payload check thunk))
                         {}
                         checks)))
          true)
        _
        false)

      _
        false)))

(defn run-check [payload check thunk]
  (let [check-run (create-check payload:repository:full-name
                                :name (str check)
                                :head-sha payload:head-sha
                                :status "in_progress"
                                :started_at (now 0))]
    (if (succeeds? thunk)
      (update-check payload:repository:full-name check-run:id
                    :status "completed"
                    :conclusion "success"
                    :completed_at (now 0))
      (update-check payload:repository:full-name check-run:id
                    :status "completed"
                    :conclusion "failure"
                    :completed_at (now 0)))))

(defn clone [repo commit]
  (git:checkout repo:url commit))

(defn decode-json [payload]
  (next (read (mkfile ./json payload) :json)))
